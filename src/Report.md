## Part 1. Инструмент ipcalc
`ipcalc` — это утилита командной строки, используемая для выполнения различных расчетов, связанных с IP-адресами и подсетями. Она позволяет пользователям:

- Преобразовывать IP-адреса между различными форматами (например, десятичный, шестнадцатеричный, двоичный)
- Вычислять маску подсети и широковещательный адрес для данной подсети
- Определять диапазон хостов в подсети
- Преобразовывать между адресами IPv4 и IPv6
- Выполнять другие расчеты, связанные с IP-адресами и подсетями

### 1.1. Сети и маски
1) Адрес сети 192.167.38.54/13
![Адрес сети](png%2Fipcalc_1.1.png)
`ipcalc 192.167.38.54/13`
- Адрес сети: 192.168.0.1
2) Перевод маски 255.255.255.0 в префиксную и двоичную запись, /15 в обычную и двоичную, 11111111.11111111.11111111.11110000 в обычную и префиксную.
![Маски](png%2Fipcalc_1.2.png)
`ipcalc 255.255.255.0`
- Префиксная запись: /24
- Двоичная запись: 11111111.11111111.11111111.00000000
![/15](png%2Fipcalc_1.3.png)
`ipcalc /15`
- Обычная запись: `255.254.0.0`
- Двоичная - `11111111.11111110.00000000.00000000`
![Binary](png%2Fipcalc_1.4.png)
`ipcalc 11111...`
- Обычная запись: `255.255.255.240`
- Префиксная запись: `/28`
![Хосты 1](png%2Fipcalc_1.5.png)
`ipcalc 12.167.38.4/8`
>При маске /8 (255.0.0.0), адрес сети будет 12.0.0.0
>
>Минимальный адрес хоста - 12.0.0.1.
> 
>Максимальный адрес хоста - 12.255.255.254.

![Хосты 2](png%2Fipcalc_1.6.png)
`ipcalc 12.167.38.4/16`
>При маске 11111111.11111111.00000000.00000000 (255.255.0.0)
>Адрес сети будет 12.167.0.0
>
>Максимальный адрес хоста - 12.167.255.254
>
>Минимальный адрес хоста - 12.167.0.1.

![Хосты 3](png%2Fipcalc_1.7.png)
`ipcalc 12.167.38.4/23`
>При маске /23 (255.255.254.0)
> 
>Адрес сети будет 12.167.38.0
>
>Минимальный адрес хоста - 12.167.38.1.
>
>Максимальный адрес хоста - 12.167.39.254

![Хосты 4](png%2Fipcalc_1.8.png)
`ipcalc 12.167.38.4/4`
>При маске /4 (240.0.0.0)
>
>Адрес сети будет 0.0.0.0/4
> 
>Максимальный адрес хоста - 15.255.255.254
>
>Минимальный адрес хоста - 0.0.0.1.

## 1.2. localhost
> Определить и записать в отчёт, можно ли обратиться к приложению, работающему на localhost, со следующими IP: 194.34.23.100, 127.0.0.2, 127.1.0.1, 128.0.0.1 
- Можно:
    - 127.0.0.1
    - 127.0.0.2
- Нельзя:
    - 194.34.23.100
    - 127.1.0.1
## 1.3. Диапазоны и сегменты сетей
> Какие из перечисленных IP можно использовать в качестве публичного, а какие только в качестве частных: 10.0.0.45, 134.43.0.2, 192.168.4.2, 172.20.250.4, 172.0.2.1, 192.172.0.1, 172.68.0.2, 172.16.255.255, 10.10.10.10, 192.169.168.1
- Частный и публичный IP-адреса можно определить по их диапазону.
Управление по присвоению номеров в Интернете (IANA) зарезервировало определенные диапазоны IP-адресов для частных сетей.
- В IPv4 есть три диапазона частных IP-адресов:
    - `Class A` 10.0.0.0 - 10.255.255.255 (префикс /8)
    - `Class B` 172.16.0.0 - 172.31.255.255 (префикс /12)
    - `Class C` 192.168.0.0 - 192.168.255.255 (префикс /16)
- Все остальные IP-адреса считаются публичными.


### - Частные адресса

    - 10.0.0.45
    - 192.168.4.2
    - 172.20.250.4
    - 172.16.255.255
    - 10.10.10.10

### - Публичные адресса

    - 134.43.0.2
    - 172.0.2.1
    - 192.172.0.1
    - 172.68.0.2
    - 192.169.168.1

> Какие из перечисленных IP адресов шлюза возможны у сети 10.10.0.0/18: 10.0.0.1, 10.10.0.2, 10.10.10.10, 10.10.100.1, 10.10.1.255

![Шлюзы](png%2Fipcalc_1.9.png)
`ipcalc 10.10.0.0/18`
- Возможны:
  - 10.10.0.2
  - 10.10.10.10
  - 10.10.1.255

- Невозможны:
  - 10.0.0.1 (меньше минимального адреса сети)
  - 10.10.100.1 (больше максимального адреса сети)

## Part 2. Статическая маршрутизация между двумя машинами
> Поднять две виртуальные машины (далее -- ws1 и ws2)

![WM1 and WM2](png%2FStatic_2.1.png)
`ws1 and ws2`

![WM1](png%2FStatic_2.2.png)
`ip a (ws1)`

![WM2](png%2FStatic_2.3.png)
`ip a (ws2)`

>Описать сетевой интерфейс, соответствующий внутренней сети, на обеих машинах и задать следующие адреса и маски: ws1 - 192.168.100.10, маска /16, ws2 - 172.24.116.8, маска /12


Интерфейс, подключенный к внутренней или домашней локальной сети организации, позволяет осуществлять обмен данными между подключенными к ней устройствами. Эти интерфейсы обычно используют приватные IP-адреса, такие как 192.168.x.x, 172.16.x.x до 172.31.x.x, или 10.x.x.x.

В настройках сети для такого интерфейса можно выбрать автоматическое присваивание IP-адресов через DHCP или назначить IP-адреса вручную, выбрав статические IP. Также доступна конфигурация дополнительных параметров, включая маску подсети, основной шлюз и DNS-серверы.

Для повышения уровня безопасности локальной сети внутренний интерфейс может быть оборудован настройками фаервола, которые предотвращают доступ к сети извне и защищают ее от внешних угроз.

- Открыть файл конфигурации сетевого интерфейса для редактирования:
`sudo nano /etc/netplan/00-installer-config.yaml`

![Static](png%2FStatic_2.3-1.png)
`ws1`

![Static](png%2FStatic_2.3-2.png)
`ws2`

- Проверяем настройки с помощью команды:
  `ip a`

![Static](png%2FStatic_2.4-1.png)
`ws1`

![Static](png%2FStatic_2.4-2.png)
`ws2`

### 2.1. Добавление статического маршрута вручную
> Добавить статический маршрут от одной машины до другой и обратно при помощи команды вида `ip r add`
`sudo ip r add <network> dev <device>`

![Static](png%2FStatic_2.5-1.png)
`ws1`

![Static](png%2FStatic_2.5-2.png)
`ws2`

> Пропинговать соединение между машинами

![Ping_ws1](png%2FStatic_2.6-2.png)
`ws1`

![Ping_ws2](png%2FStatic_2.6-1.png)
`ws2`

### 2.2. Добавление статического маршрута с сохранением
> Перезапустить машины

Статические маршруты, которые были установлены вручную, были потеряны после того, как машина была перезагружена. 

> Добавить статический маршрут от одной машины до другой с помощью файла etc/netplan/00-installer-config.yaml

Чтобы гарантировать, что статический маршрут останется неизменным и после перезапуска системы, необходимо внести изменения в файл конфигурации сети. Для этого используем nano для редактирования файла конфигурации, выполнив команду:

> `sudo nano /etc/netplan/00-installer-config.yaml`

![Static_2](png%2FStatic_2.7-1.png)
`ws1`

![Static_2](png%2FStatic_2.7-2.png)
`ws2`

Применяем новую конфигурацию файла:

> `sudo netplan apply`

> Пропинговать соединение между машинами

![Ping_ws1](png%2FStatic_2.8-1.png)
`ws1`

![Ping_ws2](png%2FStatic_2.8-2.png)
`ws2`

## Part 3. Утилита iperf3

### 3.1. Скорость соединения

> Перевести и записать в отчёт: 8 Mbps в MB/s, 100 MB/s в Kbps, 1 Gbps в Mbps

- 8 Mbps == 1 MB/s
- 100 MB/s == 800000 Kbps
- 1 Gbps == 1000 Mbps

### 3.2. Утилита iperf3

`Iperf3` - это инструмент командной строки для оценки пропускной способности сетевых соединений. Этот инструмент применяется для тестирования скорости передачи данных между устройствами в сети, где одно устройство выступает в роли сервера, а другое — клиента. Во время теста клиент передаёт данные серверу, и программа оценивает скорость передачи данных, задержки и другие характеристики соединения.

Чтобы создать сервер испольузется команда:

>`iperf3 -s [option]`

Опция `-f` позволяет выбрать формат отображения результатов тестирования (k - килобиты, m - мегабиты, g - гигабиты или K - килобайты, M - мегабайты, G - гигабайты).

Опция `-D` запускает сервер в режиме демона, что означает его работу в фоновом режиме без вывода результатов на экран. Это полезно для проведения длительных тестов или при тестировании со множеством клиентов.
Чтобы запустить **iperf3** в клиентском режиме используем флаг **-с** и указываем адрес хоста, на котором работает сервер.

`iperf3 -c [host_address] [option]`

> Измерить скорость соединения между ws1 и ws2

Чтобы измерить скорость передачи данных между двумя ВМ создадим на ws1 сервер, а на ws2 клиента.

Создадим сервер на ws1 командой:

`iperf3 -s `

Создадим клиента на ws2, делающего запрос на созданный ранее сервер:

`iperf3 -c 192.168.100.10`

![Iperf3](png%2FStatic_2.9-1.png)
`ws1 (server)`

![Iperf3](png%2FStatic_2.9-2.png)
`ws2 (client)`

Скорость соединения:

- sender: 4.89 Gbit/sec
- receiver: 4.87 Gbit/sec

## Part 4. Сетевой экран
Межсетевой экран, или фаервол, представляет собой комплекс программных и/или аппаратных средств, задачей которых является контроль сетевого трафика, обеспечение защиты информационной инфраструктуры и предотвращение несанкционированных доступов и атак.

### 4.1. Утилита iptables
Утилита `iptables` в операционной системе Linux предназначена для управления правилами фильтрации трафика на уровне командной строки. Этот инструмент позволяет настроить правила для контроля доступа через определённые порты, с использованием различных протоколов и IP-адресов.

Используя `iptables`, можно сконфигурировать фаервол для отсеивания сетевого трафика, допуская проход только тем пакетам, которые соответствуют установленным критериям.

Стандартная формулировка команд `iptables` представляет собой:

> $ iptables [параметр] [цепочка] [правило]

- `A` - дополнить цепочку новым правилом;

- `С` - осуществить проверку правил;

- `D` - исключить правило из цепочки;

- `I` - внедрить правило на определённую позицию;

- `L` - отобразить список правил в цепочке;

- `S` - представить полный список правил;

- `F` - очистить цепочку от правил;

- `N` - создать новую цепочку;

- `X` - ликвидировать ненужную цепочку;

- `P` - назначить стандартное действие для цепочки.

Параметры для настройки правил включают в себя:


- `p` - определить протокол (tcp, udp, udplite, icmp, icmpv6, esp, ah, sctp или mh);
- `s` - задать IP-адрес источника;
- `d` - указать IP-адрес назначения;
- `i` - определить входящий сетевой интерфейс;
- `o` - указать исходящий сетевой интерфейс;
- `j` - задать действие, которое следует выполнить, если условия правила удовлетворены.

> Создать файл /etc/firewall.sh, имитирующий фаерволл, на ws1 и ws2:

В `/etc/` создаем файл firewall.sh на ws1 и ws2:

`sudo nano /etc/firewall.sh`

> Нужно добавить в файл подряд следующие правила:
>1. На ws1 применить стратегию когда в начале пишется запрещающее правило, а в конце пишется разрешающее правило
>2. на ws2 применить стратегию когда в начале пишется разрешающее правило, а в конце пишется запрещающее правило (это касается пунктов 4 и 5)
>3. открыть на машинах доступ для порта 22 (ssh) и порта 80 (http)
>4. запретить echo reply (машина не должна "пинговаться”, т.е. должна быть блокировка на OUTPUT)
>5. разрешить echo reply (машина должна "пинговаться")

![Firewall](png%2FFirewall_3.1-1.png)
`ws1`

![Firewall](png%2FFirewall_3.1-2.png)
`ws2`

> Запустить файлы на обеих машинах командами chmod +x /etc/firewall.sh и /etc/firewall.sh

![Firewall](png%2FFirewall_3.2-1.png)
`ws1`

![Firewall](png%2FFirewall_3.2-2.png)
`ws2`

В первом файле на самом верху списка правил находится команда, запрещающая исходящие пинги, из-за чего первый компьютер не в состоянии отправить пинг второму компьютеру. Во втором файле, напротив, первое правило разрешает пинги, позволяя таким образом второму компьютеру пинговать другие машины. Основное отличие в подходах заключается в том, что в iptables правила применяются последовательно, начиная с верхней части списка.

### 4.2. Утилита nmap
`Nmap` - это мощный инструмент для сканирования сети, который позволяет определить, какие устройства находятся в сети, какие порты открыты, а также какие службы запущены на удаленных узлах. Этот инструмент позволяет администраторам сети обнаруживать уязвимости в сетевой инфраструктуре и предотвращать атаки.
> Командой ping найти машину, которая не "пингуется", после чего утилитой nmap показать, что хост машины запущен

![Nmap](png%2FFirewall_4.1-1.png)
ws1 `ping 172.24.116.8`

![Nmap](png%2FFirewall_4.1-2.png)
ws2 `ping 192.168.100.10`

Проверяем работу ws1, которая не пингуется.
> `sudo nmap 192.168.100.10`

![Nmap](png%2FFirewall_4.2.png)
`sudo nmap 192.168.100.10`

Как и ожидалось, ws1 не может отправить эхо-запрос (ping) ws2 из-за настроек цепочки INPUT в таблице FILTER, хотя ws2 по-прежнему может отправлять эхо-запросы ws1.

## Part 5. Статическая маршрутизация сети
Статическая маршрутизация - это метод маршрутизации, при котором администратор сети вручную настраивает маршруты для пакетов данных. Этот метод используется для определения пути передачи данных между узлами сети, когда сеть маленькая и не меняется часто.

![network_route.png](..%2Fmisc%2Fimages%2Fnetwork_route.png)
Схема будущей сети

>Поднять пять виртуальных машин (3 рабочие станции (ws11, ws21, ws22) и 2 роутера (r1, r2))

Создаем 5 машин и называем их как указанно в схеме выше

Перед запуском машин настраиваем сеть в настройках:

к стандартному подключению NAT, отвечающему за интернет соединение добавляю:
- r1 - слот 2:  `внутренняя сеть - intnet_1`, слот 3: `внутренняя сеть - intnet_2`
- r2 - слот 2:  `внутренняя сеть - intnet_2`, слот 3: `внутренняя сеть - intnet_3`
- ws11 - слот 2:  `внутренняя сеть - intnet_1`
- ws21 - слот 2:  `внутренняя сеть - intnet_3`
- ws22 - слот 2:  `внутренняя сеть - intnet_3`

>Настроить конфигурации машин в etc/netplan/00-installer-config.yaml согласно сети на рисунке.

Настраиваем статический ip в соответсвии со схемой для каждой машины:

![Config](png%2FStatic_5.1-1.png)
`r1`

![Config](png%2FStatic_5.1-2.png)
`r2`

![Config](png%2FStatic_5.1-3.png)
`ws11`

![Config](png%2FStatic_5.1-4.png)
`ws21`

![Config](png%2FStatic_5.1-5.png)
`ws22`

> Перезапустить сервис сети. Если ошибок нет, то командой ip -4 a проверить, что адрес машины задан верно. Также пропинговать ws22 с ws21. Аналогично пропинговать r1 с ws11.

Перезапускаем сервисы сети с помощью команды: `sudo netplan apply`

Проверяем адреса сетевых интерфесов машины командой: `ip  a`

![Check](png%2FStatic_5.2-1.png)
`r1`

![Check](png%2FStatic_5.2-2.png)
`r2`

![Check](png%2FStatic_5.2-3.png)
`ws11`

![Check](png%2FStatic_5.2-4.png)
`ws21`

![Check](png%2FStatic_5.2-5.png)
`ws22`

> Пропинговать ws22 с ws21. Аналогично пропинговать r1 с ws11.

![Ping](png%2FStatic_5.3-1.png)
`ping ws21 -> ws22`

![Ping](png%2FStatic_5.3-2.png)
`ping ws11 -> r1`

![Ping](png%2FStatic_5.3-3.png)
`ping r1 -> r2`

### 5.2. Включение переадресации IP-адресов.
> Для включения переадресации IP, выполните команду на роутерах:
> `sudo sysctl -w net.ipv4.ip_forward=1`

Команда `sudo sysctl -w net.ipv4.ip_forward=1` активирует функцию IP-форвардинга в ядре системы, что необходимо для того, чтобы устройство могло перенаправлять трафик между различными сетями.

`sysctl` применяется для управления параметрами ядра.

Опция `-w` служит для записи нового значения параметра.

`net.ipv4.ip_forward` - это конкретный параметр, отвечающий за IP-форвардинг на уровне ядра.

Установка этого параметра в `1` включает функцию форвардинга. Если установить значение в `0`, форвардинг будет отключен.

> Для включения переадресации IP, выполните команду на роутерах:
> 
> `sysctl -w net.ipv4.ip_forward=1`

> При таком подходе переадресация не будет работать после перезагрузки системы.

![Sysctl](png%2FStatic_5.4-1.png)
`r1`

![Sysctl](png%2FStatic_5.4-2.png)
`r2`

> Откройте файл /etc/sysctl.conf и добавьте в него следующую строку:

> `net.ipv4.ip_forward = 1`
> При использовании этого подхода, IP-переадресация включена на постоянной основе.

Добавление строки в sysctl.conf:

![Sysctl](png%2FStatic_5.5-1.png)
`r1`

![Sysctl](png%2FStatic_5.5-2.png)
`r2`

#### 5.3. Установка маршрута по-умолчанию
> Настроить маршрут по-умолчанию (шлюз) для рабочих станций. Для этого добавить default перед IP роутера в файле конфигураций

Настраиваем в конфигурации yaml файла ip роутеров в качестве шлюза по-умолчанию:

![Route](png%2FStatic_5.6-1.png)
`ws11`

![Route](png%2FStatic_5.6-2.png)
`ws21`

![Route](png%2FStatic_5.6-3.png)
`ws22`

Применяем изменения в силу: `sudo netplan apply`

> Вызвать ip r и показать, что добавился маршрут в таблицу маршрутизации

![Route](png%2FStatic_5.7-1.png)
`ws11`

![Route](png%2FStatic_5.7-2.png)
`ws21`

![Route](png%2FStatic_5.7-3.png)
`ws22`

> Вызвать ip r и показать, что добавился маршрут в таблицу маршрутизации

> Пропинговать с ws11 роутер r2 и показать на r2, что пинг доходит.

Используем команду `tcpdump -tn -i eth1` для захвата сетевого трафика на сетевом интерфейсе eth1 в неименованном числовом формате, что позволяет наблюдать за сетевыми пакетами без разрешения имен доменов и портов. Это полезно для мониторинга сетевого трафика, диагностики сетевых проблем и выявления точек затора.

- Опция `-tn` обеспечивает вывод IP-адресов и портов в числовом формате, исключая необходимость в DNS-резолвинге.
- Флаг `-i eth1` указывает на конкретный сетевой интерфейс — eth1, где будет проводиться захват пакетов.
- При попытке пинга `r2` с `ws11` ответа не последует из-за отсутствия на `r2` настроек маршрутизации. 

Однако, выполнив `tcpdump -tn -i eth1 на r2`, можно увидеть, что сигнал доходит до устройства.

Чтобы проверить это, необходимо запустить команду на `r2` и одновременно начать пинговать `r2` с `ws11`.

![Tcpdump](png%2FStatic_5.8-1.png)
`r2`

![Tcpdump](png%2FStatic_5.8-2.png)
`ws11`

На `r2` мы видим что сигнал от `ws11` доходит, но не возвращается назад.

### 5.4. Добавление статических маршрутов
> Добавить в роутеры r1 и r2 статические маршруты в файле конфигураций. Пример для r1 маршрута в сетку 10.20.0.0/26:


Для того чтобы роутеры могли определить, к какому роутеру направлять трафик для определенного IP-адреса, надо сконфигурировать статические маршруты путем редактирования файла YAML.

`sudo nano /etc/netplan/00-installer-config.yaml`

![Static_route](png%2FStatic_5.9-1.png)
`r1`

![Static_route](png%2FStatic_5.9-2.png)
`r2`

Применяем изменения в силу: `sudo netplan apply`

> Вызвать ip r и показать таблицы с маршрутами на обоих роутерах. 

![Static_route](png%2FStatic_5.10-1.png)
`r1`

![Static_route](png%2FStatic_5.10-2.png)
`r2`

> Запустить команды на ws11:
`ip r list 10.10.0.0/[маска сети]`и `ip r list 0.0.0.0/0`

![Static_route](png%2FStatic_5.11.png)
`ws11`


Так как ws11 располагается в подсети 10.10.0.0/18, она обращается к другим устройствам внутри этой же подсети, используя собственный IP-адрес. В случае необходимости взаимодействия с устройствами вне данной подсети, ws11 направляет трафик через шлюз по умолчанию, который, в свою очередь, перенаправляет эти данные к нужной сети.

### 5.5. Построение списка маршрутизаторов
> Запустить на r1 команду дампа: `tcpdump -tnv -i eth0`


Команда `tcpdump -tnv -i eth0` запускает утилиту `tcpdump` для захвата сетевого трафика на интерфейсе eth0 в текстовом формате.

`-t` - отключает вывод временной метки

`-n` - отключает вывод имени хоста (или ip-адреса, если опция -n применяется и для анализа IP-адресов)

`-v` - увеличивает уровень детализации вывода

`-i` eth0 - задает интерфейс `eth0`, на котором будет происходить захват

![Tcpdump](png%2FStatic_5.12.png)

> При помощи утилиты traceroute построить список маршрутизаторов на пути от ws11 до ws21

Используя команду traceroute, можно отправлять последовательность пакетов с постепенно возрастающим параметром TTL (время жизни) для отслеживания маршрута и времени прохождения пакетов через каждый из маршрутизаторов по пути к заданному пункту назначения. Это дает возможность узнать маршрут следования данных и время их доставки до каждой точки маршрута.

![Traceroute](png%2FStatic_5.13-1.png)
`ws11`

![Traceroute](png%2FStatic_5.13-2.png)
`r1`

### Использование протокола ICMP при маршрутизации

`ICMP (Internet Control Message Protocol)` - это протокол, используемый для передачи сообщений об ошибках и управляющих сообщений в сетях IP. ICMP обычно используется для тестирования сети и диагностики соединений. Он работает на уровне интернета (IP) и использует специальные сообщения, называемые ICMP-сообщениями, для передачи информации между устройствами в сети.

> Запустить на r1 перехват сетевого трафика, проходящего через eth0 с помощью команды:

![Tcpdump](png%2FStatic_5.14.png)
`sudo tcpdump -n -i eth0 icmp`

>Пропинговать с ws11 несуществующий IP (например, 10.30.0.111) с помощью команды: `ping -c 5 10.30.0.111`

![Ping](png%2FStatic_5.15-1.png)
`ws11`

![Tcpdump](png%2FStatic_5.15-2.png)
`r1`

## Part 6. Динамическая настройка IP с помощью DHCP


`DHCP (Dynamic Host Configuration Protocol)` является протоколом сетевого уровня, обеспечивающим автоматическое присваивание IP-адресов и других сетевых настроек устройствам в сети. Благодаря `DHCP` устраняется необходимость ручной настройки сетевых параметров для каждого устройства, что значительно облегчает управление сетью.

Чтобы воспользоваться функционалом DHCP в нашей локальной сети, требуется наличие DHCP-сервера или dhcpd.

`dhcpd` — это сервис DHCP, который автоматизирует процесс настройки сетевых параметров подключенных к сети устройств.

Установка этого сервиса производится командой:

`sudo apt-get install isc-dhcp-server`

`ISC-DHCP (Internet Systems Consortium Dynamic Host Configuration Protocol)` представляет собой реализацию сервера DHCP от Internet Systems Consortium. Этот протокол обеспечивает автоматическую настройку сетевых параметров для компьютеров и других устройств в сети, включая IP-адреса, маски подсети, шлюзы по умолчанию, DNS-серверы и другие. ISC-DHCP предлагает средства для настройки и управления DHCP-сервером на платформе Linux.

>Для настройки DHCP на `r2` необходимо отредактировать файл конфигурации `/etc/dhcp/dhcpd.conf`, указав в нем адрес шлюза по умолчанию, DNS-сервер и диапазон IP-адресов для внутренней сети.

![DHCP](png%2FDynamic_6.1.png)
`r2`

> В файле resolv.conf прописать nameserver 8.8.8.8.

![DHCP](png%2FDynamic_6.2.png)
`r2`

> Перезагрузить службу DHCP командой systemctl restart isc-dhcp-server. Машину ws21 перезагрузить при помощи reboot и через ip a показать, что она получила адрес. Также пропинговать ws22 с ws21.

`sudo systemctl restart isc-dhcp-server`

`sudo systemctl status isc-dhcp-server`

![DHCP](png%2FDynamic_6.3.png)
`r2`

На ws21 и ws22 сделаем DHCP-протокол аткивным и принимаем новые настройски netplan:

![DHCP](png%2FDynamic_6.4-1.png)
`ws21`

![DHCP](png%2FDynamic_6.4-2.png)
`ws22`

`sudo netplan apply`

![DHCP](png%2FDynamic_6.5-1.png)
`ws21`

![DHCP](png%2FDynamic_6.5-2.png)
`ws22`

> Указать MAC адрес у ws11, для этого в etc/netplan/00-installer-config.yaml надо добавить строки: macaddress: 10:10:10:10:10:BA, dhcp4: true

Заходим в yaml файл и добавляем туда новый MAC-адрес и активируем DHCP-протокол:

![DHCP](png%2FDynamic_6.6.png)
`ws11`

Выключаем машину и меняем настройки ее MAC-адрес:

![DHCP](png%2FDynamic_6.7.png)
`ws11`

> Для r1 настроить аналогично r2, но сделать выдачу адресов с жесткой привязкой к MAC-адресу (ws11). Провести аналогичные тесты

На r1 нужно также установить dhcpd и отредактировать его с жесткой привязкой к MAC-адресу хоста (ws11). Это значит что конкретный ip внутри одной локальной сети будет всегда принадлежать устройству с конкретны MAC-адресом.

![DHCP](png%2FDynamic_6.8.png)
`r1`

Также изменяем параметры на yaml файле ws11, чтобы ей было можно выдать динамичный ip и перезапустим ее командой `reboot`

> Запросить с ws21 обновление ip адреса

Чтобы запросить обновление ip адреса на для ws21 сперва используем команду для удаления старого адреса:
`sudo dhclient -r`

Затем запрашиваем новый адрес:
`sudo dhclient -v`

![DHCP](png%2FDynamic_6.9.png)
`ws21`

> В отчёте описать, какими опциями DHCP сервера пользовались в данном пункте.

- `option routers` определяет стандартный маршрутизатор для DHCP-клиентов.
- `option domain-name-servers` назначает DNS-серверы для использования клиентами в процессе преобразования доменных имен в IP-адреса.
- `option domain-name` устанавливает доменное имя по умолчанию для клиентов, получающих конфигурацию через DHCP.

## Part 7. NAT
> В файле /etc/apache2/ports.conf на ws22 и r1 изменить строку Listen 80 на Listen 0.0.0.0:80, то есть сделать сервер Apache2 общедоступным

`Apache2` - это свободный веб-сервер, который позволяет создавать и хостить веб-сайты и веб-приложения.

Для начала нам необходимо установить программу apache2 на наши виртуальные машины:

`sudo apt-get install apache2`

`Listen 80` означает, что сервер будет слушать все доступные IP-адреса на порту 80. Таким образом, сервер будет слушать запросы на порту 80 как с локального хоста, так и с других устройств, если они будут иметь доступ к серверу.

`Listen 0.0.0.0:80` тоже самое, но явно указывает, что сервер должен слушать все доступные IP-адреса.

Изменяем этот параметр в файле `/etc/apache2/ports.conf`

![NAT](png%2FDynamic_7.1.png)

> Запустить веб-сервер Apache командой service apache2 start на ws22 и r1 

`sudo service apache2 start`

![NAT](png%2FDynamic_7.2-1.png)
`ws22`

![NAT](png%2FDynamic_7.2-2.png)
`r1`

> Добавить в фаервол, созданный по аналогии с фаерволом из Части 4, на r2 следующие правила:

Создаём файл `firewall.sh` с помощью команды: `sudo nano /etc/firewall.sh`

Добавляем в файл следующие инструкции:

- Очистка всех существующих правил в таблице `filter — iptables -F`.

- Очистка всех существующих правил в таблице `NAT — iptables -F -t nat`.

- Установка политики отбрасывания всех транзитных пакетов — `iptables --policy FORWARD DROP`.

![NAT](png%2FDynamic_7.3.png)

Даем права этому файлу и запускаем его:

`sudo chmod +x /etc/firewall.sh`

`sudo bash /etc/firewall.sh`

> Проверить соединение между ws22 и r1 командой ping


При запуске файла с этими правилами, ws22 не должна "пинговаться" с r1</i>

Так как мы запретили пропуск пакетов на r2, то r1 не может пинговать ws22:

![NAT](png%2FDynamic_7.4-1.png)
`ws22`

Также пинг не проходит и в обратную сторону с ws22 на r1

![NAT](png%2FDynamic_7.4-2.png)
`r1`

> Добавить в файл ещё одно правило: разрешить маршрутизацию всех пакетов протокола ICMP

Чтобы разрешить маршрутизацию всех пакетов протокола ICMP с помощью iptables, необходимо выполнить следующую команду:

`iptables -A FORWARD -p icmp -j ACCEPT`

![NAT](png%2FDynamic_7.5.png)

Применяем новые правила и проверяем таблицу правил:

![NAT](png%2FDynamic_7.6.png)

> Проверить соединение между ws22 и r1 командой ping

![NAT](png%2FDynamic_7.7-1.png)
`ws22`

![NAT](png%2FDynamic_7.7-2.png)
`r1`

> Добавить в файл ещё два правила:
> - включить SNAT, а именно маскирование всех локальных ip из локальной сети, находящейся за r2 (по обозначениям из Части 5 - сеть 10.20.0.0)
> - включить DNAT на 8080 порт машины r2 и добавить к веб-серверу Apache, запущенному на ws22, доступ извне сети

`SNAT (Source Network Address Translation) и DNAT (Destination Network Address Translation)` - это два типа трансляции IP-адресов, используемых для изменения адресов источника и назначения в IP-пакетах при прохождении через маршрутизатор.

![SNAT-DNAT](png%2FDynamic_7.8.png)
/etc/firewall на r2`

Принимаем новые правила:
`sudo chmid +x /etc/firewall` и `sudo bash /etc/firewall`

> Проверить соединение по TCP для SNAT, для этого с ws22 подключиться к серверу Apache на r1 командой: `telnet [адрес] [порт]`

- Telnet - это протокол прикладного уровня, использующийся для удаленного управления устройствами через интернет или локальную сеть. С помощью Telnet можно подключаться к серверам, обычно по протоколу TCP, и взаимодействовать с ними, отправляя команды и получая ответы.

Подключаемся к серверу apache установленному на r1 с ws22:
`telnet 10.100.0.11 80`

![SNAT-DNAT](png%2FDynamic_7.9-1.png)
`ws22`

> Проверить соединение по TCP для DNAT, для этого с r1 подключиться к серверу Apache на ws22 командой telnet (обращаться по адресу r2 и порту 8080)

![SNAT-DNAT](png%2FDynamic_7.9-2.png)
`r1`

## Part 8. Дополнительно. Знакомство с SSH Tunnels
## Part 8. Дополнительно. Знакомство с SSH Tunnels

Запускаем фаерволы, сделанные в предыдущих заданиях: `sudo chmod +x /etc/firewall.sh` и

`sudo bash /etc/firewall.sh`


> Запустить веб-сервер Apache на ws22 только на localhost (то есть в файле  изменить строку Listen 80 на Listen localhost:80)
`sudo nano /etc/apache2/ports.conf`

Изменяем listen и запускаем сервер apache:

![SSH](png%2FApa_8.1.png)
`ws22`

![SSH](png%2FApa_8.2.png)

> Воспользоваться Local TCP forwarding с ws21 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws21

`Local TCP forwarding` (также известен как локальное перенаправление портов) - это метод использования SSH для перенаправления трафика между клиентской машиной и сервером SSH. Этот метод позволяет клиентской машине использовать SSH-соединение как "прокси-сервер" для обращения к удаленным ресурсам.`

В нашем случае, мы можем использовать Local TCP forwarding для перенаправления трафика с порта 8080 на ws21 на порт 80 на ws22. Для этого нужно выполнить следующую команду на ws21:

`ssh -L 80:ws22:8888 user-1@10.20.0.20`

![SSH](png%2FApa_8.3.png)
`ws21`